package com.example.androidaudiorecorder;
import android.content.Context;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Application: DogAudioMonitor
 * Component: Event Tagging
 *
 *
 * This class is an Activity in which the user can play back and tag all events generated by
 * the WavFileEventFilterActivity. All tagged events will be utilized by the monitor to compare with live audio.
 * The taggedWav Files and the ones created by the monitor will be compared via a DTW algorithm after MFCC extraction
 * an email notification will be triggered if DTW distance is small enough.
 * Uses 2 instance of the Timer Task Runnable Thread class to concurrently run the WavRecord and WavCompare class
 * in a schedule.
 *
 * @author Emma Cox
 *
 *
 */
public class AudioMonitorActivity extends AppCompatActivity {

    //Activity Context
    public   Context context = this;


    //Instance vars

    private String userName  ;

    private  String email  ;

    private  String phone  ;

    private String accuracyLevel ;

    private int accuracyThreshold;


    //File Directory, Unfortunately this had to be hard coded as the getFileDir.toString method was not providing correct file path for for accessing files.
    final String fileDirectory = "/data/data/com.example.androidaudiorecorder/files/";

    public Button closeApp;

    public Button stop;
    /**
     * Default Constructor that sets all instance variables to 0/null
     */
    public AudioMonitorActivity(){

    }


    //Class getters and setters
    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getAccuracyLevel() {
        return accuracyLevel;
    }

    public void setAccuracyLevel(String accuracyLevel) {
        this.accuracyLevel = accuracyLevel;
    }

    public int getAccuracyThreshold() {
        return accuracyThreshold;
    }

    public void setAccuracyThreshold(int accuracyThreshold) {
        this.accuracyThreshold = accuracyThreshold;
    }


    /*This is first set as an empty Collection and will then contain he taggedWavs from the EventTaggingActivity
     *  upon creating the Activity
     *  The list is set as volatile due to the use of timer Thread classes. The modifier insures
     *  that any thread that reads the list will see the most recently written values (in this case those provided by
     *  the EventTaggingActivity
     */
    private   volatile List<File> taggedWavs = Collections.emptyList();




    /*Every time a wavFile is Recorded by the WavRecord class in the recordTimer the filepath is added to this
     * blocking queue. When the wavCompare task is scheduled to occur it takes the filePath and uses it to compare
     * with the taggedWavs list.
     */
    public BlockingQueue<String> fileQueue = new LinkedBlockingQueue<>();


    @Override
    /**
     * When Activity is Activated during application run
     */
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        //Gets the values from the UserSettingsActivity

        userName = getIntent().getExtras().getString("Name");


        email = getIntent().getExtras().getString("email");


        phone = getIntent().getExtras().getString("phone");

        accuracyLevel = getIntent().getExtras().getString("accuracy");


        //taggedwavs is assigned the ArrayList of tagged WavFiles passed from last activity.
        taggedWavs = (ArrayList<File>)getIntent().getSerializableExtra("wavs");

        Toast.makeText(  context, "tag  " +   taggedWavs.size(), Toast.LENGTH_SHORT).show();

        /*
         *Depending on the String Accuracy value from the last class (1-5), the switch
         * will create an int AccuracyThreshold value to be used bythe DTW algorith in the WavCompare class.
         */
        setContentView(R.layout.activity_audio_monitor);
        switch(accuracyLevel) {
            case "1" :
                accuracyThreshold =4;
                break;

            case "2":
                accuracyThreshold = 6;
                break;

            case "3":
                accuracyThreshold = 8;
                break;

            case "4":
                accuracyThreshold = 10;
                break;

            case "5":
                accuracyThreshold =12 ;
                break;

            default :
                accuracyThreshold = 6;



        }


        //Initialize WavRecord class instance with fileQueue in constructor
         final WavRecord wavRecord = new WavRecord(fileQueue);
        final Timer recordTimer = new Timer();
        recordTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {


                        wavRecord.launchTask(context);
                        Toast.makeText(  context, "queue  " +   fileQueue.isEmpty(), Toast.LENGTH_SHORT).show();

                    }
                });
            }
        }, 0, 30000); //Records WavFile Continuously every 30 seconds


        //Initialize WavComapre class instance with context, fileQueue, user details, accuracyThreshold and taggedWavs passed in constructor.
        final WavCompare wavCompareThread = new WavCompare(context, fileQueue, userName,email,phone,accuracyThreshold,taggedWavs, fileDirectory);
        final Timer compareTimer = new Timer();

        compareTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {

                        if (!fileQueue.isEmpty()){
                            try{
                                //takes top of Queue filePath in fileQueue
                                wavCompareThread.startCompare(fileQueue.take(), context);

                            }catch (InterruptedException e){

                            }
                        }





                    }
                });
            }
        }, 35000, 35000); //Delay of 35 seconds to allow wavFile to be completed and added to fileQueue before starting



        stop = (Button) findViewById(R.id.btnStopMonitor);
        stop.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                recordTimer.cancel();
                compareTimer.cancel();

                Toast.makeText(context, "Finished Monitoring your home ", Toast.LENGTH_SHORT).show();
            }
        });


    }



}