package com.example.androidaudiorecorder;import android.content.Context;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import java.io.File;import java.util.ArrayList;/** * Application: DogAudioMonitor * Component: Audio Monitor * * * This class is an Activity that takes the enrollment wav file and filters out the high energy sections. * Each section is considered a significant audio "Event" and converted into it's own individual wav file. * This class initiates Enrollment wavFile And uses an Instance of the RecordWavTask to execute its recording. * The user can start Recording and stop anytime before moving on the the WavEventFilter Activity. * * @author Emma Cox * @author Dr. Andrew Greensted, 2010 * @author Joren Six * @author * * http://www.labbookpages.co.uk/audio/javaWavFiles.html * */public class WavFileEventFilterActivity extends AppCompatActivity {    // Instance Variables used in class    private Context context = WavFileEventFilterActivity.this;    private static ArrayList<ArrayList<Integer>> significantEvenIDCollect = new ArrayList<ArrayList<Integer>>();    private static int sampleRate;    private static double threshold ;//Button that creates Events and starts next Activity    private Button getEvent;    /**     * Default Constructor that sets all instance variables to 0/null     */    public WavFileEventFilterActivity(){    }    /**     * When Activity is Activated during application run     *     */    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_wavfile_eventfilter);        getEvent= (Button) findViewById(R.id.btnEvent);        getEvent.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                readEnrollmentWav(context);            }        });    }    /**     * Creates a WavFile object with the enrollment wav file created in the last Activity     * Reads WavFile object into an Array buffer of frames     * @throws 'Exception'     */    public   void readEnrollmentWav(Context context) {        try{            // Open the wav file specified as the first argument            WavFile wavFile = WavFile.openWavFile(new File(getFilesDir(),"recording_DOG.wav"));;            sampleRate = (int) wavFile.getSampleRate();            // Create a variable that stores number of frames in file.            int numFrames = (int) wavFile.getNumFrames();            double duration = numFrames/sampleRate;            // Get the number of audio channels in the wav file            int numChannels = wavFile.getNumChannels();            // Create a buffer of frames            double[] buffer = new double[numFrames * numChannels];            int framesRead;            do {                // Read frames into buffer                framesRead = wavFile.readFrames(buffer, numFrames);            } while (framesRead != 0);            // Array List to store 100 frames in each element            ArrayList<double[]> frameCollect = new ArrayList<double[]>();            // Splits buffer into chunks of 441 frames and adds to frameCollect            splitBufferAddToList(buffer, 441, frameCollect);            //Gets high energy sections(events) from buffer            getSignificantEvents(buffer, significantEvenIDCollect, context);            // Close the wavFile            wavFile.close();        } catch (Exception e) {            System.err.println(e);        }    }    /**     * Splits array into a smaller arrays of a specified chunk size.     * Adds Each Array to an ArrayList of Arrays      * @param array     * @param sectionSize     * @param frameCollect     *     */    public static void splitBufferAddToList(double[] array, int sectionSize, ArrayList<double[]> frameCollect ) {        int numberOfSections = (int) Math.ceil((double) array.length / sectionSize);        double[][] output = new double[numberOfSections][];        for (int loop = 0; loop < numberOfSections; ++loop) {            int start = loop * sectionSize;            int length = Math.min(array.length - start, sectionSize);            double[] temp = new double[length];            System.arraycopy(array, start, temp, 0, length);            output[loop] = temp;            frameCollect.add(temp);        }        //Gets RMS values for each element of frameCollection        RMSCollect(frameCollect );    }    /**     *Find the RMS of each element of 441 frames .      Add each value to an ArrayList     * @param frameCollect     *     */    public static void RMSCollect(ArrayList<double[]> frameCollect) {        // ArrayList to contain all RMS values        ArrayList<Double> rmsValues = new ArrayList<Double>();        for (int loop = 0; loop < frameCollect.size(); loop++) {            rmsValues.add(rootMeanSquare(frameCollect.get(loop)));        }        for (int loop = 0; loop < rmsValues.size(); loop++) {            // System.out.println( " RMS VALS " + loop + " " + rmsValues.get(loop));        }        //Calculates a RMS threshold value.        energyThreshold(rmsValues);    }    /**     * Algorithm that calculates the average RMS value of each element of frameCollection     * @param frameSection     * @return     */    public static double rootMeanSquare(double[] frameSection) {        double sum = 0.0;        for (double num : frameSection)            sum += num * num;        return Math.sqrt(sum / frameSection.length);    }    /**     * Algorithm that calculates the energy threshold that will be used to filter out events from original wav file     * @param rmsValues     *     */    public static void energyThreshold(ArrayList<Double> rmsValues) {        double total = 0;        double average = 0;        for (int loop = 0; loop < rmsValues.size(); loop++) {            // System.out.println("RMS " + rmsValues.get(loop));            total += rmsValues.get(loop);        }        average = total / rmsValues.size();        threshold = average  * 0.5 ;        significantEventIDs(threshold                , rmsValues);    }    /**     * Uses Threshold value to filter out all rmsValues from ArrayList that are greater or equal to it     * @param threshold     * @param rmsValues     */    public static void significantEventIDs(double threshold, ArrayList<Double> rmsValues) {        ArrayList<Integer> significantEventRMSID = new ArrayList<Integer>();        for (int loop = 0; loop < rmsValues.size(); loop++) {            /*             Any RMS value greater than or equal to threshold adds their position in loop to an Arraylist             as a means to identify the the high energy frames from the RMS value it represents .             */            if (rmsValues.get(loop) >= threshold) {                significantEventRMSID.add(loop);                //This will continue until an RMS value in list drops below threshold            } else if (rmsValues.get(loop) < threshold && significantEventRMSID.size() > 0) {                significantEvenIDCollect.add(significantEventRMSID);                //The Arraylist is added to an ArrayList of Integer ArrayLists                //This adds all each collection of high RMS IDs to an individual element.                significantEventRMSID = new ArrayList<Integer>();                /*The signigicantEventRMSID array is then cleared until the next                value in loop is greater than or equal to threshold                 */            }        }    }    /**     * This takes the ArrayList consisting of Collections of RMSIDs and uses them to identify the original frames     * from buffer that make up each significant event.     *     * @param buffer     * @param significantEventIDCollect     * @param context     */    public  void getSignificantEvents(double[] buffer,                                      ArrayList<ArrayList<Integer>> significantEventIDCollect, Context context) {        //Each element is a frame within the event        ArrayList<Double> bufferEvent = new ArrayList<Double>();       ArrayList<ArrayList<Double>> bufferEventsCollect = new ArrayList<ArrayList<Double>>();        //Outer loop iterates through each event (Collection of IDS) in the ArrayList        for (int outerLoop = 0; outerLoop < significantEventIDCollect.size(); outerLoop++) {             /*             To find the first frame in the buffer Event. The first RMS ID in the Collection              is Multiplied by 441 (The amount of frames in each element of orginal enrollment buffer).              */            int firstID = significantEventIDCollect.get(outerLoop).get(0);            int firstFrame = firstID * 441;            /*            To find the position of the last frame in the buffer Event. The Amount of IDs in the current element            is Multiplied by 441 and added to the position of the first frame.            */            int totalIDs = significantEventIDCollect.get(outerLoop).size();            int lastFrame = (totalIDs * 441) + firstFrame;            /*            The innner loop gathers all frames at a position >= to firstFrame and <= lastFrame            An ands them to the bufferEvent Collection            Each buffer Event is added to an ArrayList             */            for (int innerLoop = 0; innerLoop < buffer.length; innerLoop++) {                if (innerLoop >= firstFrame && innerLoop <= lastFrame) {                    bufferEvent.add(buffer[innerLoop]);                }            }            bufferEventsCollect.add(bufferEvent);            // Creates a new buffer event            bufferEvent = new ArrayList<Double>();        }        //If events are below a certain length they are removed from collection.        for (int loop = bufferEventsCollect.size()-1 ;   loop >=0; loop--) {            if ( bufferEventsCollect.get(loop).size() <=  20000) {                bufferEventsCollect.remove(loop);            }        }        String fileName = null;        int fileNameID = 0;        //Gives a numbered fileName to each event        for (int loop = 0 ;   loop < bufferEventsCollect.size(); loop++) {            fileNameID ++;            fileName = "event"+  Integer.toString(fileNameID );            //Creates wavFiles from event with unique numbered filename            //Overwritten Each time events are created            createEventWav(bufferEventsCollect.get(loop), fileName);        }        //Passes the amount of Events created from this wav  file to the next activity.        int size = bufferEventsCollect.size();        Intent intent = new Intent(WavFileEventFilterActivity.this, EventTaggingActivity.class);        intent.putExtra("size", size);        startActivity(intent);    }    /**     * Creates a wavFile from Each Event     * @param event     * @param fileName     *     */    public  void createEventWav(ArrayList<Double> event, String fileName) {        File  wavEvent = new File(getFilesDir(), fileName+ ".wav");        try {            int sampleRate = 44100; // Samples per second            double duration = event.size() / sampleRate; // Seconds            // Calculate the number of frames required for specified duration            long numFrames = (long) (event.size());            // Create a wav file with the name specified as the first argument            WavFile wavFileEvent = WavFile.newWavFile( wavEvent, 1, numFrames, 16, sampleRate);            // Create a buffer            double[] bufferEvent = new double[(int) numFrames];            for (int loop = 0; loop < event.size(); loop++) {                bufferEvent[loop] = event.get(loop);            }            int numberFrames = (int) numFrames;            //Write Frames from buffer to WavFile            wavFileEvent.writeFrames(bufferEvent, numberFrames);            // Close the wavFile            wavFileEvent.close();        } catch (Exception e) {            System.err.println(e);        }    }    /**     * calculate frequency using zero crossings (NOT USED)     *     */    public static int calculate0Crossings(int sampleRate, ArrayList<Double> audioData) {        int numSamples = audioData.size();        int numCrossing = 0;        for (int p = 0; p < numSamples - 1; p++) {            if ((audioData.get(p) > 0 && audioData.get(p + 1) <= 0)                    || (audioData.get(p) < 0 && audioData.get(p + 1) >= 0)) {                numCrossing++;            }        }        float numSecondsRecorded = (float) numSamples / (float) sampleRate;        float numCycles = numCrossing / 2;        float frequency = numCycles / numSecondsRecorded;        return (int) frequency;    }}